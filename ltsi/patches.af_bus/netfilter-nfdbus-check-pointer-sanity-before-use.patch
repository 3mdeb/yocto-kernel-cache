From javier.martinez@collabora.co.uk Wed Jun 12 02:00:28 2013
From: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
Date: Wed, 12 Jun 2013 11:00:00 +0200
Subject: netfilter: nfdbus: check pointer sanity before use.
To: Greg KH <gregkh@linuxfoundation.org>
Cc: ltsi-dev@lists.linuxfoundation.org, Awais Belal <awais.belal@mentor.com>, genivi-ipc@lists.genivi.org
Message-ID: <1371027600-26999-1-git-send-email-javier.martinez@collabora.co.uk>


From: Awais Belal <awais.belal@mentor.com>

match_rule_search() can return a NULL pointer if it does not
find the required rule but the returned pointer was not being
checked for NULL in the calling function
bus_matchmaker_remove_rule_by_value(). This caused a NULL pointer dereference
issue in cases where a rule could not be found in the tree.

Signed-off-by: Awais Belal <awais.belal@mentor.com>
---

Hello Greg,

This is another bugfix for AF_BUS that has to be applied
on top of the fixes I sent last week [1].

Thanks a lot and best regards,
Javier

[1]: http://lists.linuxfoundation.org/pipermail/ltsi-dev/2013-June/001692.html

 net/bus/nfdbus/matchrule.c |   22 ++++++++++++----------
 1 file changed, 12 insertions(+), 10 deletions(-)

--- a/net/bus/nfdbus/matchrule.c
+++ b/net/bus/nfdbus/matchrule.c
@@ -840,16 +840,18 @@ void bus_matchmaker_remove_rule_by_value
 			match_rule_search(&pool->rules_by_iface,
 					  rule->interface);
 
-		struct hlist_node *cur;
-		struct bus_match_rule *cur_rule;
-		hlist_for_each_entry(cur_rule, cur, &head->first, list) {
-			if (match_rule_equal(cur_rule, rule)) {
-				hlist_del(cur);
-				if (hlist_empty(&head->first))
-					rb_erase(&head->node,
-						 &pool->rules_by_iface);
-				bus_match_rule_free(cur_rule);
-				break;
+		if (head) {
+			struct hlist_node *cur;
+			struct bus_match_rule *cur_rule;
+			hlist_for_each_entry(cur_rule, cur, &head->first, list) {
+				if (match_rule_equal(cur_rule, rule)) {
+					hlist_del(cur);
+					if (hlist_empty(&head->first))
+						rb_erase(&head->node,
+							 &pool->rules_by_iface);
+					bus_match_rule_free(cur_rule);
+					break;
+				}
 			}
 		}
 	} else {
