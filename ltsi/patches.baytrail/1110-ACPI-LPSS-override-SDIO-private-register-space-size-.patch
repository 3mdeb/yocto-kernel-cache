From 949e5dd3fdd0056eaf25e09d6e21497aa296c109 Mon Sep 17 00:00:00 2001
From: Mika Westerberg <mika.westerberg@linux.intel.com>
Date: Tue, 18 Jun 2013 16:51:35 +0300
Subject: ACPI / LPSS: override SDIO private register space size from ACPI
 tables

The SDIO device in Lynxpoint has its LTR registers reserved for a
WiFi device (a child of the SDIO device) in the ACPI namespace even
though those registers physically belong to the SDIO device itself.
In order to be able to access the SDIO LTR registers from the ACPI
LPSS driver for diagnostic purposes we need to use a size override
for the SDIO private register space.

Add a possibility to override the size of the private register space
of an LPSS device provided by the ACPI tables in the ACPI LPSS driver
and set the correct size for the SDIO device in there.

[rjw: Changelog]
Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 958c4eb2aa325099ea1f54c7354e381e3d79f3ae)
Signed-off-by: Darren Hart <dvhart@linux.intel.com>
---
 drivers/acpi/acpi_lpss.c | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index b3f36a8ce006..fb78bb9ad8f6 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -48,6 +48,7 @@ struct lpss_device_desc {
 	const char *clkdev_name;
 	bool ltr_required;
 	unsigned int prv_offset;
+	size_t prv_size_override;
 	bool clk_gate;
 	struct lpss_shared_clock *shared_clock;
 	void (*setup)(struct lpss_private_data *pdata);
@@ -91,6 +92,7 @@ static struct lpss_device_desc lpt_uart_dev_desc = {
 
 static struct lpss_device_desc lpt_sdio_dev_desc = {
 	.prv_offset = 0x1000,
+	.prv_size_override = 0x1018,
 	.ltr_required = true,
 };
 
@@ -249,7 +251,10 @@ static int acpi_lpss_create_device(struct acpi_device *adev,
 
 	list_for_each_entry(rentry, &resource_list, node)
 		if (resource_type(&rentry->res) == IORESOURCE_MEM) {
-			pdata->mmio_size = resource_size(&rentry->res);
+			if (dev_desc->prv_size_override)
+				pdata->mmio_size = dev_desc->prv_size_override;
+			else
+				pdata->mmio_size = resource_size(&rentry->res);
 			pdata->mmio_base = ioremap(rentry->res.start,
 						   pdata->mmio_size);
 			break;
-- 
1.8.5.rc3

