From 1a5e8c3032df430709e2942ffe1466d37fbbfa0c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ville=20Syrj=C3=A4l=C3=A4?= <ville.syrjala@linux.intel.com>
Date: Wed, 4 Sep 2013 18:30:04 +0300
Subject: drm/i915: Check pixel clock limits on pre-gen4
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

We don't want to try to push the hardware beyond it's capabilities,
so check the pixel clock against the display core clock limit. Do
it for pre-gen4 for now since that's where we alread have the double
wide pixel clock limit check.

Let's assume that when double wide mode is enabled the max
pixel clock limit is also doubled.

FIXME: panel fitter downscaling probably affects the limit on
non-pch platforms too, so we'd need another version of
ilk_pipe_pixel_rate() to figure that out.

FIXME: should check the limits on all platforms. Also sprites
affect the max allowed pixel rate on some platforms, so we need
to eventually tie all the planes and pipes into one check in
the future. But we need plane state pre-compute before that can
happen.

Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
(cherry picked from commit ad3a44799510e778a6b4bf7999618634bdd6615d)
Signed-off-by: Darren Hart <dvhart@linux.intel.com>
---
 drivers/gpu/drm/i915/intel_display.c | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c
index 7711088beb6b..5aa46477d375 100644
--- a/drivers/gpu/drm/i915/intel_display.c
+++ b/drivers/gpu/drm/i915/intel_display.c
@@ -4139,6 +4139,7 @@ static int intel_crtc_compute_config(struct intel_crtc *crtc,
 	struct drm_device *dev = crtc->base.dev;
 	struct drm_display_mode *adjusted_mode = &pipe_config->adjusted_mode;
 
+	/* FIXME should check pixel clock limits on all platforms */
 	if (INTEL_INFO(dev)->gen < 4) {
 		struct drm_i915_private *dev_priv = dev->dev_private;
 		int clock_limit =
@@ -4152,8 +4153,13 @@ static int intel_crtc_compute_config(struct intel_crtc *crtc,
 		 * the only reason for the pipe == PIPE_A check?
 		 */
 		if (crtc->pipe == PIPE_A &&
-		    adjusted_mode->clock > clock_limit * 9 / 10)
+		    adjusted_mode->clock > clock_limit * 9 / 10) {
+			clock_limit *= 2;
 			pipe_config->double_wide = true;
+		}
+
+		if (adjusted_mode->clock > clock_limit * 9 / 10)
+			return -EINVAL;
 	}
 
 	/* Cantiga+ cannot handle modes with a hsync front porch of 0.
-- 
1.8.5.rc3

