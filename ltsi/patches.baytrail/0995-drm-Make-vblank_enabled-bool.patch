From 51c5a567d754fc2177d734100250bbcfa599cf7e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ville=20Syrj=C3=A4l=C3=A4?= <ville.syrjala@linux.intel.com>
Date: Fri, 4 Oct 2013 14:53:35 +0300
Subject: drm: Make vblank_enabled bool
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

vblank_enabled is only ever 0 or 1, so make it a bool.

Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Dave Airlie <airlied@redhat.com>
(cherry picked from commit bf507d90cf0eecf5495f66f21dbb66e35e9131ae)
Signed-off-by: Darren Hart <dvhart@linux.intel.com>
---
 drivers/gpu/drm/drm_irq.c          | 8 ++++----
 drivers/gpu/drm/omapdrm/omap_irq.c | 2 +-
 include/drm/drmP.h                 | 2 +-
 3 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/drivers/gpu/drm/drm_irq.c b/drivers/gpu/drm/drm_irq.c
index 81b4c84449a4..49680a8ab96a 100644
--- a/drivers/gpu/drm/drm_irq.c
+++ b/drivers/gpu/drm/drm_irq.c
@@ -115,7 +115,7 @@ static void vblank_disable_and_save(struct drm_device *dev, int crtc)
 	spin_lock_irqsave(&dev->vblank_time_lock, irqflags);
 
 	dev->driver->disable_vblank(dev, crtc);
-	dev->vblank_enabled[crtc] = 0;
+	dev->vblank_enabled[crtc] = false;
 
 	/* No further vblank irq's will be processed after
 	 * this point. Get current hardware vblank count and
@@ -235,7 +235,7 @@ int drm_vblank_init(struct drm_device *dev, int num_crtcs)
 	if (!dev->vblank_refcount)
 		goto err;
 
-	dev->vblank_enabled = kcalloc(num_crtcs, sizeof(int), GFP_KERNEL);
+	dev->vblank_enabled = kcalloc(num_crtcs, sizeof(bool), GFP_KERNEL);
 	if (!dev->vblank_enabled)
 		goto err;
 
@@ -412,7 +412,7 @@ int drm_irq_uninstall(struct drm_device *dev)
 		spin_lock_irqsave(&dev->vbl_lock, irqflags);
 		for (i = 0; i < dev->num_crtcs; i++) {
 			DRM_WAKEUP(&dev->vbl_queue[i]);
-			dev->vblank_enabled[i] = 0;
+			dev->vblank_enabled[i] = false;
 			dev->last_vblank[i] =
 				dev->driver->get_vblank_counter(dev, i);
 		}
@@ -973,7 +973,7 @@ int drm_vblank_get(struct drm_device *dev, int crtc)
 			if (ret)
 				atomic_dec(&dev->vblank_refcount[crtc]);
 			else {
-				dev->vblank_enabled[crtc] = 1;
+				dev->vblank_enabled[crtc] = true;
 				drm_update_vblank_count(dev, crtc);
 			}
 		}
diff --git a/drivers/gpu/drm/omapdrm/omap_irq.c b/drivers/gpu/drm/omapdrm/omap_irq.c
index 9263db117ff8..3cbe92c72fd5 100644
--- a/drivers/gpu/drm/omapdrm/omap_irq.c
+++ b/drivers/gpu/drm/omapdrm/omap_irq.c
@@ -308,7 +308,7 @@ int omap_drm_irq_uninstall(struct drm_device *dev)
 		spin_lock_irqsave(&dev->vbl_lock, irqflags);
 		for (i = 0; i < dev->num_crtcs; i++) {
 			DRM_WAKEUP(&dev->vbl_queue[i]);
-			dev->vblank_enabled[i] = 0;
+			dev->vblank_enabled[i] = false;
 			dev->last_vblank[i] =
 				dev->driver->get_vblank_counter(dev, i);
 		}
diff --git a/include/drm/drmP.h b/include/drm/drmP.h
index 227292ae8736..d3b7d2c96d23 100644
--- a/include/drm/drmP.h
+++ b/include/drm/drmP.h
@@ -1165,7 +1165,7 @@ struct drm_device {
 	atomic_t *vblank_refcount;      /* number of users of vblank interruptsper crtc */
 	u32 *last_vblank;               /* protected by dev->vbl_lock, used */
 					/* for wraparound handling */
-	int *vblank_enabled;            /* so we don't call enable more than
+	bool *vblank_enabled;           /* so we don't call enable more than
 					   once per disable */
 	int *vblank_inmodeset;          /* Display driver is setting mode */
 	u32 *last_vblank_wait;		/* Last vblank seqno waited per CRTC */
-- 
1.8.5.rc3

