From 48cc6fb24264915a9ada52d5202b9a0b4741bb4d Mon Sep 17 00:00:00 2001
From: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date: Sun, 2 Jun 2013 01:50:25 +0400
Subject: phy-rcar-usb: correct base address

The memory region that is used by the driver overlaps EHCI and OHCI  register
regions for absolutely no reason now  -- fix it  by adding offset of 0x800 to
the base address, changing the register #define's accordingly. This has extra
positive effect that we now can use devm_ioremap_resource()...

Note that the driver and the SoC code have to be in one patch to keep the code
bisectable...

The patch has been tested on the Marzen board.

Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Acked-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Acked-by: Felipe Balbi <balbi@ti.com>
Signed-off-by: Simon Horman <horms+renesas@verge.net.au>
(cherry picked from commit 725bf9dcafe16aa69c8ab34c63ba36c6eb4492f2)
Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

Conflicts:
	arch/arm/mach-shmobile/setup-r8a7779.c
---
 drivers/usb/phy/phy-rcar-usb.c | 28 ++++++++++------------------
 1 file changed, 10 insertions(+), 18 deletions(-)

diff --git a/drivers/usb/phy/phy-rcar-usb.c b/drivers/usb/phy/phy-rcar-usb.c
index 4893dbde..d636cc74 100644
--- a/drivers/usb/phy/phy-rcar-usb.c
+++ b/drivers/usb/phy/phy-rcar-usb.c
@@ -16,13 +16,13 @@
 #include <linux/spinlock.h>
 #include <linux/module.h>
 
-/* USBH common register */
-#define USBPCTRL0	0x0800
-#define USBPCTRL1	0x0804
-#define USBST		0x0808
-#define USBEH0		0x080C
-#define USBOH0		0x081C
-#define USBCTL0		0x0858
+/* REGS block */
+#define USBPCTRL0	0x00
+#define USBPCTRL1	0x04
+#define USBST		0x08
+#define USBEH0		0x0C
+#define USBOH0		0x1C
+#define USBCTL0		0x58
 
 /* USBPCTRL1 */
 #define PHY_RST		(1 << 2)
@@ -139,17 +139,9 @@ static int rcar_usb_phy_probe(struct platform_device *pdev)
 		return -EINVAL;
 	}
 
-	/*
-	 * CAUTION
-	 *
-	 * Because this phy address is also mapped under OHCI/EHCI address area,
-	 * this driver can't use devm_request_and_ioremap(dev, res) here
-	 */
-	reg0 = devm_ioremap_nocache(dev, res0->start, resource_size(res0));
-	if (!reg0) {
-		dev_err(dev, "ioremap error\n");
-		return -ENOMEM;
-	}
+	reg0 = devm_ioremap_resource(dev, res0);
+	if (IS_ERR(reg0))
+		return PTR_ERR(reg0);
 
 	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
 	if (!priv) {
-- 
1.8.4.3.gca3854a

