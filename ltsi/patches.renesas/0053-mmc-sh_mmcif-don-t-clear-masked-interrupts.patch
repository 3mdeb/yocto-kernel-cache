From 73a9361644d86ae17d6ad8957433f301336d88a3 Mon Sep 17 00:00:00 2001
From: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
Date: Wed, 15 May 2013 07:50:51 +0200
Subject: mmc: sh_mmcif: don't clear masked interrupts

Masking events on MMCIF means that an occurrence of the masked event
won't raise an interrupt, but the event bit will still be set in the
interrupt status register. If simultaneously a different event occurs
which was enabled, both flags will be set. However, only the unmasked
event bit should be cleared in the status register in such a case.

Clearing also the masked bit can lead to lost interrupts, which indeed
can be observed on the armadillo800eva r8a7740 board with an eMMC chip.
The problem has been introduced by the recent "mmc: sh_mmcif: simplify
IRQ processing" patch. Fix the problem by only clearing enabled interrupts.

Signed-off-by: Guennadi Liakhovetski <g.liakhovetski+renesas@gmail.com>
Tested-by: Nguyen Viet Dung <nv-dung@jinso.co.jp>
Tested-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Signed-off-by: Chris Ball <cjb@laptop.org>
(cherry picked from commit 19f1ba51c79f133aec3ce558b8292e3b081363f3)
Signed-off-by: Simon Horman <horms+renesas@verge.net.au>
---
 drivers/mmc/host/sh_mmcif.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/drivers/mmc/host/sh_mmcif.c b/drivers/mmc/host/sh_mmcif.c
index a23f6c06..3ae1a1f8 100644
--- a/drivers/mmc/host/sh_mmcif.c
+++ b/drivers/mmc/host/sh_mmcif.c
@@ -1244,7 +1244,8 @@ static irqreturn_t sh_mmcif_intr(int irq, void *dev_id)
 	u32 state;
 
 	state = sh_mmcif_readl(host->addr, MMCIF_CE_INT);
-	sh_mmcif_writel(host->addr, MMCIF_CE_INT, ~state);
+	sh_mmcif_writel(host->addr, MMCIF_CE_INT,
+			~(state & sh_mmcif_readl(host->addr, MMCIF_CE_INT_MASK)));
 	sh_mmcif_bitclr(host, MMCIF_CE_INT_MASK, state & MASK_CLEAN);
 
 	if (state & ~MASK_CLEAN)
-- 
1.8.4.3.gca3854a

