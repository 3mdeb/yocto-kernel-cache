From e2a9bae78e869e001df7dbcc6b4a312d8ad53130 Mon Sep 17 00:00:00 2001
From: Chew, Chiau Ee <chiau.ee.chew@intel.com>
Date: Mon, 13 Jan 2014 02:24:00 +0800
Subject: [PATCH 04/17] serial: 8250: Add custom baud rate support for BYT
 ACPI mode HSUART

This is to enable 1M, 2M, 3M & 4M baud-rate support for BYT ACPI mode
HSUART.

Based on Heikki's work (commit b15e5691 serial: 8250_pci:
add support for Intel BayTrail)

Signed-off-by: Chew, Chiau Ee <chiau.ee.chew@intel.com>
---
 drivers/tty/serial/8250/8250_dw.c  |   48 ++++++++++++++++++++++++++++++++++++
 drivers/tty/serial/8250/8250_pci.c |    6 ++++
 2 files changed, 54 insertions(+), 0 deletions(-)

diff --git a/drivers/tty/serial/8250/8250_dw.c b/drivers/tty/serial/8250/8250_dw.c
index b9cf0ef..65cb760 100644
--- a/drivers/tty/serial/8250/8250_dw.c
+++ b/drivers/tty/serial/8250/8250_dw.c
@@ -95,6 +95,53 @@ static unsigned int dw8250_serial_in32(struct uart_port *p, int offset)
 	return readl(p->membase + offset);
 }

+#define BYT_PRV_CLK			0x800
+#define BYT_PRV_CLK_EN			(1 << 0)
+#define BYT_PRV_CLK_M_VAL_SHIFT		1
+#define BYT_PRV_CLK_N_VAL_SHIFT		16
+#define BYT_PRV_CLK_UPDATE		(1 << 31)
+
+static void
+dw8250_set_termios(struct uart_port *p, struct ktermios *termios,
+		   struct ktermios *old)
+{
+	struct uart_8250_port *up =
+		container_of(p, struct uart_8250_port, port);
+	unsigned int baud = tty_termios_baud_rate(termios);
+	unsigned int m = 6912;
+	unsigned int n = 15625;
+	u32 reg;
+
+	/*
+	 * For baud rates 1000000, 2000000 and 4000000 the dividers must be
+	 * adjusted.
+	 */
+	if (baud == 1000000 || baud == 2000000 || baud == 4000000) {
+		m = 64;
+		n = 100;
+
+		p->uartclk = 64000000;
+	} else if (baud == 3000000) {
+		m = 48;
+		n = 100;
+
+		p->uartclk = 48000000;
+	} else {
+		p->uartclk = 44236800;
+	}
+
+	/* Reset the clock */
+	reg = (m << BYT_PRV_CLK_M_VAL_SHIFT) | (n << BYT_PRV_CLK_N_VAL_SHIFT);
+	writel(reg, p->membase + BYT_PRV_CLK);
+	reg |= BYT_PRV_CLK_EN | BYT_PRV_CLK_UPDATE;
+	writel(reg, p->membase + BYT_PRV_CLK);
+
+	/* For Intel BayTrail, hs-uart is capable of auto flow control */
+	up->capabilities |= UART_CAP_AFE;
+
+	serial8250_do_set_termios(p, termios, old);
+}
+
 static int dw8250_handle_irq(struct uart_port *p)
 {
 	struct dw8250_data *d = p->private_data;
@@ -231,6 +278,7 @@ static int dw8250_probe_acpi(struct uart_port *p)
 	p->iotype = UPIO_MEM32;
 	p->serial_in = dw8250_serial_in32;
 	p->serial_out = dw8250_serial_out32;
+	p->set_termios = dw8250_set_termios;
 	p->regshift = 2;

 	if (!p->uartclk)
diff --git a/drivers/tty/serial/8250/8250_pci.c b/drivers/tty/serial/8250/8250_pci.c
index 581ea6e..b61cd9e 100644
--- a/drivers/tty/serial/8250/8250_pci.c
+++ b/drivers/tty/serial/8250/8250_pci.c
@@ -1096,6 +1096,8 @@ static void
 byt_set_termios(struct uart_port *p, struct ktermios *termios,
 		struct ktermios *old)
 {
+	struct uart_8250_port *up =
+		container_of(p, struct uart_8250_port, port);
 	unsigned int baud = tty_termios_baud_rate(termios);
 	unsigned int m = 6912;
 	unsigned int n = 15625;
@@ -1165,9 +1167,13 @@ byt_serial_setup(struct serial_private *priv,
 		return -EINVAL;
 	}

+	dma->rxconf.direction = DMA_DEV_TO_MEM;
+	dma->rxconf.src_addr_width = 1;
 	dma->rxconf.slave_id = dma->rx_chan_id;
 	dma->rxconf.src_maxburst = 16;

+	dma->txconf.direction = DMA_MEM_TO_DEV;
+	dma->txconf.dst_addr_width = 1;
 	dma->txconf.slave_id = dma->tx_chan_id;
 	dma->txconf.dst_maxburst = 16;

--
1.7.4.4

