From c4c38e7dcd4e925f624cc7fe18aeaad841fd7d6f Mon Sep 17 00:00:00 2001
From: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date: Mon, 21 Dec 2015 18:17:10 +0100
Subject: [PATCH] sched: reset task's lockless wake-queues on fork()

In 7675104990ed ("sched: Implement lockless wake-queues") we gained
lockless wake-queues. -RT managed to lockup itself with those. There
could be multiple attempts for task X to enqueue it for a wakeup
_even_ if task X is already running.
The reason is that task X could be runnable but not yet on CPU. The the
task performing the wakeup did not leave the CPU it could performe
multiple wakeups.
With the proper timming task X could be running and enqueued for a
wakeup. If this happens while X is performing a fork() then its its
child will have a !NULL `wake_q` member copied.
This is not a problem as long as the child task does not participate in
lockless wakeups :)

Fixes: 7675104990ed ("sched: Implement lockless wake-queues")
Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
---
 kernel/fork.c |    1 +
 1 file changed, 1 insertion(+)

--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -380,6 +380,7 @@ static struct task_struct *dup_task_stru
 #endif
 	tsk->splice_pipe = NULL;
 	tsk->task_frag.page = NULL;
+	tsk->wake_q.next = NULL;
 
 	account_kernel_stack(ti, 1);
 
